<?php
declare(strict_types=1);

namespace Gdbots\Schemas\Ncr;

use Gdbots\Pbj\Assertion;
use Gdbots\Pbj\Message;
use Gdbots\Pbj\MessageRef;
use Gdbots\Pbj\SchemaQName;
use Gdbots\Pbj\WellKnown\Identifier;

/**
 * A NodeRef is a qualified identifier to a node/vertex.  It is less verbose than a MessageRef
 * as it is implied that node labels must be unique within a given vendor namespace and
 * therefore can be represented in a more compact manner.
 *
 * NodeRef Format:
 *  vendor:label:id
 *
 * The "vendor:label" portion is a SchemaQName.  @see SchemaQName
 *
 * @link http://s3.thinkaurelius.com/docs/titan/1.0.0/schema.html section: 5.4. Defining Vertex Labels
 * @link https://neo4j.com/docs/developer-manual/current/introduction/#graphdb-neo4j-labels
 *
 * Examples:
 *  acme:article:41e4532f-2f58-4b9d-afc8-e9c2cbcb4aba
 *  twitter:tweet:789234931599835136
 *  youtube:video:EG0wQRsXLi4
 *
 */
class NodeRef implements Identifier
{
    /** @var SchemaQName */
    private $qname;

    /**
     * Any string matching pattern /^[\w\/\.:-]+$/
     * @var string
     */
    private $id;

    /**
     * When serialized we store the qname as a string so we can
     * restore the singleton instance upon wakeup.
     *
     * @var string
     */
    private $qn;

    /**
     * @param SchemaQName $qname
     * @param string      $id
     *
     * @throws \Exception
     */
    public function __construct(SchemaQName $qname, string $id)
    {
        $this->qname = $qname;
        $this->id = trim($id);
        Assertion::regex($this->id, '/^[\w\/\.:-]+$/', null, 'NodeRef.id');
    }

    /**
     * @param string $string A string with format vendor:label:id
     *
     * @return self
     */
    public static function fromString($string)
    {
        $parts = explode(':', $string, 3);
        Assertion::count($parts, 3, 'NodeRef format must be "vendor:label:id');
        $id = array_pop($parts);
        $qname = SchemaQName::fromString(implode(':', $parts));
        return new self($qname, $id);
    }

    /**
     * @param Message $node
     *
     * @return self
     */
    public static function fromNode(Message $node): self
    {
        return new self($node::schema()->getQName(), (string)$node->get('_id'));
    }

    /**
     * @param MessageRef $messageRef
     *
     * @return self
     */
    public static function fromMessageRef(MessageRef $messageRef): self
    {
        return new self(SchemaQName::fromCurie($messageRef->getCurie()), $messageRef->getId());
    }

    /**
     * @return SchemaQName
     */
    public function getQName(): SchemaQName
    {
        return $this->qname;
    }

    /**
     * @return string
     */
    public function getVendor(): string
    {
        return $this->qname->getVendor();
    }

    /**
     * @return string
     */
    public function getLabel(): string
    {
        return $this->qname->getMessage();
    }

    /**
     * @return string
     */
    public function getId(): string
    {
        return $this->id;
    }

    /**
     * {@inheritdoc}
     */
    public function toString()
    {
        return $this->qname->toString() . ':' . $this->id;
    }

    /**
     * {@inheritdoc}
     */
    public function __toString()
    {
        return $this->toString();
    }

    /**
     * {@inheritdoc}
     */
    public function jsonSerialize()
    {
        return $this->toString();
    }

    /**
     * {@inheritdoc}
     */
    public function equals(Identifier $other)
    {
        return $this == $other;
    }

    /**
     * Creates a NodeRef from a file path, assuming it was generated by the "toFilePath" method.
     *
     * @param string $string
     *
     * @return static
     */
    public static function fromFilePath(string $string): self
    {
        $parts = explode('/', $string, 5);
        unset($parts[2]);
        unset($parts[3]);

        return self::fromString(
            str_replace(['__FS__', '__CLN__'], ['/', ':'], implode(':', $parts))
        );
    }

    /**
     * Returns a string that can be used for a file path.  Special characters
     * in the id, colon and forward slash, are replaced with "__CLN__" and "__FS__"
     * respectively.  The path is also hashed so for large repositories all files
     * don't end up in the same directory.
     *
     * @return string
     */
    public function toFilePath(): string
    {
        $hash = md5($this->id);
        return trim(sprintf(
            '%s/%s/%s/%s/%s',
            $this->qname->getVendor(),
            $this->qname->getMessage(),
            substr($hash, 0, 2),
            substr($hash, 2, 2),
            str_replace(['/', ':'], ['__FS__', '__CLN__'], $this->id)
        ), '/');
    }

    /**
     * {@inheritdoc}
     */
    public function __sleep()
    {
        $this->qn = $this->qname->toString();
        return ['qn', 'id'];
    }

    /**
     * {@inheritdoc}
     */
    public function __wakeup()
    {
        $this->qname = SchemaQName::fromString($this->qn);
        $this->qn = null;
    }
}
