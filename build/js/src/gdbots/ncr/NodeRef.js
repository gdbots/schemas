/* eslint-disable no-useless-escape */
import md5 from 'md5';
import trim from 'lodash/trim';
import AssertionFailed from '@gdbots/pbj/exceptions/AssertionFailed';
import Identifier from '@gdbots/pbj/well-known/Identifier';
import SchemaQName from '@gdbots/pbj/SchemaQName';

/**
 * A NodeRef is a qualified identifier to a node/vertex.  It is less verbose than a MessageRef
 * as it is implied that node labels must be unique within a given vendor namespace and
 * therefore can be represented in a more compact manner.
 *
 * NodeRef Format:
 *  vendor:label:id
 *
 * The "vendor:label" portion is a SchemaQName.  @see SchemaQName
 *
 * @link http://s3.thinkaurelius.com/docs/titan/1.0.0/schema.html section: 5.4. Defining Vertex Labels
 * @link https://neo4j.com/docs/developer-manual/current/introduction/#graphdb-neo4j-labels
 *
 * Examples:
 *  acme:article:41e4532f-2f58-4b9d-afc8-e9c2cbcb4aba
 *  twitter:tweet:789234931599835136
 *  youtube:video:EG0wQRsXLi4
 *
 */
export default class NodeRef extends Identifier {
  /**
   * @param {SchemaQName|string} qname
   * @param {string} id
   */
  constructor(qname, id) {
    const value = `${qname}:${id}`;
    super(value);

    this.qname = SchemaQName.fromString(`${qname}`);
    this.id = trim(id);

    if (!/^[\w\/\.:-]+$/.test(this.id)) {
      throw new AssertionFailed(`NodeRef.id "${this.value}" is invalid.`);
    }

    Object.freeze(this);
  }

  /**
   * @param {string} value
   *
   * @returns {NodeRef}
   */
  static fromString(value) {
    const [vendor, label, ...rest] = value.split(':');
    return new NodeRef(`${vendor}:${label}`, rest.join(':'));
  }

  /**
   * @param {Message} node
   *
   * @returns {NodeRef}
   */
  static fromNode(node) {
    return new NodeRef(node.schema().getQName(), node.get('_id'));
  }

  /**
   * @param {MessageRef} ref
   *
   * @returns {NodeRef}
   */
  static fromMessageRef(ref) {
    return new NodeRef(SchemaQName.fromCurie(ref.getCurie()), ref.getId());
  }

  /**
   * @returns {SchemaQName}
   */
  getQName() {
    return this.qname;
  }

  /**
   * @returns {string}
   */
  getVendor() {
    return this.qname.getVendor();
  }

  /**
   * @returns {string}
   */
  getLabel() {
    return this.qname.getMessage();
  }

  /**
   * @returns {string}
   */
  getId() {
    return this.id;
  }

  /**
   * Creates a NodeRef from a file path, assuming it was generated by the "toFilePath" method.
   *
   * @param {string} value
   *
   * @returns {NodeRef}
   */
  static fromFilePath(value) {
    const parts = value.split('/');
    parts.splice(2, 2);
    return NodeRef.fromString(parts.join(':').replace(/__FS__/g, '/').replace(/__CLN__/g, ':'));
  }

  /**
   * Returns a string that can be used for a file path.  Special characters
   * in the id, colon and forward slash, are replaced with "__CLN__" and "__FS__"
   * respectively.  The path is also hashed so for large repositories all files
   * don't end up in the same directory.
   *
   * @returns {string}
   */
  toFilePath() {
    const hash = md5(this.id);
    const id = this.id.replace(/\//g, '__FS__').replace(/:/g, '__CLN__');
    const str = `${this.qname.getVendor()}/${this.qname.getMessage()}/${hash.substr(0, 2)}/${hash.substr(2, 2)}/${id}`;
    return trim(str, '/');
  }
}
